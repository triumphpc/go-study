// Паттерн "Leader Election" используется в распределенных системах для выбора одного узла в качестве лидера, который будет
//выполнять определенные задачи или принимать решения от имени всей группы узлов. Этот паттерн помогает координировать
//действия в кластере и обеспечивает согласованность и надежность системы.
//
//Когда использовать Leader Election
//Координация задач: Когда необходимо координировать выполнение задач между несколькими узлами, чтобы избежать дублирования работы.
//Распределенные системы: Когда система состоит из множества узлов, и требуется централизованное управление или принятие решений.
//Обеспечение отказоустойчивости: Когда необходимо обеспечить автоматическое восстановление и переназначение лидера в случае сбоя текущего лидера.
//Управление ресурсами: Когда требуется централизованное управление ресурсами или конфигурацией в кластере.
//Плюсы Leader Election
//Централизованное управление: Обеспечивает централизованное управление и координацию задач в кластере.
//Отказоустойчивость: Позволяет автоматически переназначать лидера в случае сбоя, обеспечивая непрерывность работы.
//Согласованность: Обеспечивает согласованность данных и действий в распределенной системе.
//Гибкость: Позволяет легко изменять лидера и адаптироваться к изменениям в кластере.
//Минусы Leader Election
//Сложность реализации: Требует тщательной реализации и управления процессом выбора лидера.
//Задержки: Может возникнуть задержка при выборе нового лидера в случае сбоя.
//Единая точка отказа: Лидер может стать единой точкой отказа, если не предусмотрены механизмы автоматического восстановления.
//Зависимость от сети: Процесс выбора лидера зависит от сетевой доступности и может быть подвержен сетевым сбоям.

package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

// Node - структура, представляющая узел в кластере
type Node struct {
	ID       int
	IsLeader bool
}

// Cluster - структура, представляющая кластер узлов
type Cluster struct {
	nodes []*Node
	mu    sync.Mutex
}

// NewCluster - создает новый кластер с заданным количеством узлов
func NewCluster(numNodes int) *Cluster {
	nodes := make([]*Node, numNodes)
	for i := 0; i < numNodes; i++ {
		nodes[i] = &Node{ID: i}
	}
	return &Cluster{nodes: nodes}
}

// ElectLeader - выбирает лидера среди узлов кластера
func (c *Cluster) ElectLeader() {
	c.mu.Lock()
	defer c.mu.Unlock()

	// Сбрасываем текущего лидера
	for _, node := range c.nodes {
		node.IsLeader = false
	}

	// Выбираем нового лидера случайным образом
	leaderIndex := rand.Intn(len(c.nodes))
	c.nodes[leaderIndex].IsLeader = true
	fmt.Printf("Node %d is elected as leader\n", c.nodes[leaderIndex].ID)
}

// MonitorCluster - мониторит кластер и переизбирает лидера в случае сбоя
func (c *Cluster) MonitorCluster() {
	for {
		time.Sleep(5 * time.Second) // Симулируем периодическую проверку

		// Случайно симулируем сбой лидера
		if rand.Float32() < 0.3 {
			fmt.Println("Leader failure detected, re-electing leader...")
			c.ElectLeader()
		}
	}
}

func main() {
	rand.Seed(time.Now().UnixNano())
	cluster := NewCluster(5)

	// Изначально выбираем лидера
	cluster.ElectLeader()

	// Запускаем мониторинг кластера
	go cluster.MonitorCluster()

	// Бесконечный цикл для симуляции работы кластера
	select {}
}
