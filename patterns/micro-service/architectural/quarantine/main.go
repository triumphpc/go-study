// Паттерн "Quarantine" используется для изоляции и обработки подозрительных или ошибочных данных или сообщений в системе.
//Этот паттерн позволяет временно изолировать данные, которые не могут быть обработаны в обычном режиме, чтобы предотвратить
//их негативное влияние на основную систему. Это особенно полезно в системах, где необходимо обеспечить надежность и устойчивость к ошибкам.
//
//Когда использовать Quarantine Pattern
//Обработка ошибок: Когда необходимо изолировать и обработать данные или сообщения, которые вызывают ошибки при обычной обработке.
//Защита системы: Когда требуется предотвратить негативное влияние ошибочных данных на основную систему.
//Анализ и исправление: Когда необходимо проанализировать и исправить ошибочные данные перед их повторной обработкой.
//Устойчивость к сбоям: Когда требуется обеспечить устойчивость системы к сбоям и ошибкам.
//Плюсы Quarantine Pattern
//Улучшение надежности: Изолирует ошибочные данные, предотвращая их негативное влияние на основную систему.
//Гибкость: Позволяет анализировать и исправлять ошибочные данные перед их повторной обработкой.
//Устойчивость к сбоям: Повышает устойчивость системы к сбоям и ошибкам.
//Централизованное управление: Обеспечивает централизованное управление ошибочными данными и их обработкой.
//Минусы Quarantine Pattern
//Сложность управления: Требует управления изолированными данными и их обработкой.
//Задержки: Может добавить задержки в обработку данных из-за необходимости их изоляции и анализа.
//Ресурсы: Может потребовать дополнительных ресурсов для хранения и обработки изолированных данных.
//Сложность реализации: Требует тщательной реализации и управления, чтобы обеспечить надежность и производительность.

package main

import (
	"errors"
	"fmt"
	"sync"
)

// Data - структура, представляющая данные
type Data struct {
	ID    int
	Value string
}

// Quarantine - структура для хранения изолированных данных
type Quarantine struct {
	data []Data
	mu   sync.Mutex
}

// NewQuarantine - создает новую карантинную зону
func NewQuarantine() *Quarantine {
	return &Quarantine{data: make([]Data, 0)}
}

// Add - добавляет данные в карантин
func (q *Quarantine) Add(d Data) {
	q.mu.Lock()
	defer q.mu.Unlock()
	q.data = append(q.data, d)
	fmt.Printf("Data ID %d added to quarantine\n", d.ID)
}

// ProcessData - функция для обработки данных
func ProcessData(d Data) error {
	if d.Value == "error" {
		return errors.New("invalid data")
	}
	fmt.Printf("Processing data ID %d: %s\n", d.ID, d.Value)
	return nil
}

func main() {
	quarantine := NewQuarantine()

	dataItems := []Data{
		{ID: 1, Value: "valid"},
		{ID: 2, Value: "error"},
		{ID: 3, Value: "valid"},
	}

	for _, data := range dataItems {
		if err := ProcessData(data); err != nil {
			fmt.Printf("Error processing data ID %d: %v\n", data.ID, err)
			quarantine.Add(data)
		}
	}

	// Обработка данных из карантина
	fmt.Println("Processing quarantined data...")
	for _, data := range quarantine.data {
		fmt.Printf("Reprocessing data ID %d: %s\n", data.ID, data.Value)
		// Здесь можно добавить логику для исправления и повторной обработки данных
	}
}
