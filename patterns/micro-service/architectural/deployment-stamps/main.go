// Паттерн "Deployment Stamps" используется для управления развертыванием приложений в различных средах и конфигурациях. Этот паттерн позволяет создавать несколько экземпляров приложения, каждый из которых может быть настроен и оптимизирован для определенной задачи или группы пользователей. Это особенно полезно в крупных системах, где разные части приложения могут иметь разные требования к производительности, безопасности или функциональности.
//
//Когда использовать Deployment Stamps Pattern
//Разные требования пользователей: Когда разные группы пользователей или клиентов имеют уникальные требования к функциональности или производительности.
//Географическое распределение: Когда необходимо развернуть приложение в разных географических регионах для улучшения производительности и доступности.
//Тестирование и разработка: Когда требуется развернуть отдельные экземпляры приложения для тестирования, разработки или демонстрации.
//Специфические конфигурации: Когда разные части приложения требуют специфических конфигураций или интеграций с другими системами.

//Плюсы Deployment Stamps Pattern
//Гибкость: Позволяет адаптировать приложение под специфические требования различных пользователей или сред.
//Масштабируемость: Обеспечивает возможность масштабирования приложения в зависимости от нагрузки и требований.
//Изоляция: Позволяет изолировать разные экземпляры приложения, что упрощает управление и отладку.
//Оптимизация ресурсов: Позволяет оптимизировать использование ресурсов, развертывая только необходимые компоненты.

//Минусы Deployment Stamps Pattern
//Сложность управления: Требует управления несколькими экземплярами приложения, что может увеличить сложность.
//Затраты на инфраструктуру: Может потребовать дополнительных ресурсов и инфраструктуры для поддержки нескольких экземпляров.
//Согласованность данных: Необходимо обеспечить согласованность данных между разными экземплярами приложения.
//Управление конфигурацией: Требует управления различными конфигурациями и настройками для каждого экземпляра.

package main

import (
	"fmt"
	"os"
	"strconv"
)

// Config - структура для хранения конфигурации
type Config struct {
	Environment string
	DatabaseURL string
	Port        int
}

// LoadConfig - загружает конфигурацию из переменных окружения
func LoadConfig() Config {
	return Config{
		Environment: getEnv("ENVIRONMENT", "development"),
		DatabaseURL: getEnv("DATABASE_URL", "localhost:5432"),
		Port:        getEnvAsInt("PORT", 8080),
	}
}

// getEnv - получает значение переменной окружения или возвращает значение по умолчанию
func getEnv(key, defaultValue string) string {
	if value, exists := os.LookupEnv(key); exists {
		return value
	}
	return defaultValue
}

// getEnvAsInt - получает значение переменной окружения как int или возвращает значение по умолчанию
func getEnvAsInt(key string, defaultValue int) int {
	if valueStr, exists := os.LookupEnv(key); exists {
		if value, err := strconv.Atoi(valueStr); err == nil {
			return value
		}
	}
	return defaultValue
}

func main() {
	config := LoadConfig()
	fmt.Printf("Running in %s environment on port %d\n", config.Environment, config.Port)
	fmt.Printf("Connecting to database at %s\n", config.DatabaseURL)
}
