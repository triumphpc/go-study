// Паттерн "Compute Resource Consolidation" используется для оптимизации использования вычислительных ресурсов в
//распределенных системах. Он предполагает объединение или консолидацию задач или процессов на меньшем количестве узлов
//или контейнеров, чтобы более эффективно использовать доступные ресурсы. Это может быть полезно для снижения затрат на
//инфраструктуру и повышения производительности.

// Когда использовать Compute Resource Consolidation
//Оптимизация ресурсов: Когда у вас есть избыточные ресурсы, которые не используются эффективно.
//Снижение затрат: Когда вы хотите уменьшить затраты на инфраструктуру, объединяя задачи на меньшем количестве серверов или контейнеров.
//Улучшение производительности: Когда консолидация задач может привести к более эффективному использованию ресурсов и улучшению производительности.

//Плюсы Compute Resource Consolidation
//Экономия затрат: Снижает затраты на инфраструктуру за счет уменьшения количества используемых серверов или контейнеров.
//Улучшение использования ресурсов: Повышает эффективность использования ресурсов, таких как CPU и память.
//Упрощение управления: Уменьшает количество узлов или контейнеров, которыми нужно управлять.

//Минусы Compute Resource Consolidation
//Риски отказа: Консолидация может увеличить риск отказа, так как больше задач зависят от меньшего количества узлов.
//Сложность балансировки нагрузки: Требуется тщательное управление и балансировка нагрузки, чтобы избежать перегрузки узлов.
//Потенциальные задержки: Может привести к задержкам, если ресурсы не распределены должным образом.

// Альтернативные варианты
// Если вы ищете другие способы оптимизации использования ресурсов, вы можете рассмотреть использование паттернов
// "Auto-Scaling" для автоматического масштабирования ресурсов или "Load Balancing"
// для распределения нагрузки между несколькими узлами.
package main

import (
	"fmt"
	"sync"
	"time"
)

// Task - функция, представляющая задачу
func Task(id int, wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Printf("Task %d is starting\n", id)
	time.Sleep(2 * time.Second) // Симуляция выполнения задачи
	fmt.Printf("Task %d is completed\n", id)
}

func main() {
	var wg sync.WaitGroup
	numTasks := 5

	// Запускаем несколько задач параллельно
	for i := 1; i <= numTasks; i++ {
		wg.Add(1)
		go Task(i, &wg)
	}

	// Ожидаем завершения всех задач
	wg.Wait()
	fmt.Println("All tasks are completed")
}
