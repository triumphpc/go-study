// Паттерн "Retry" используется для повышения надежности системы путем повторной попытки выполнения операции, которая
//не удалась из-за временной ошибки. Это особенно полезно в распределенных системах, где сбои могут быть вызваны
//временными проблемами, такими как сетевые сбои или временная недоступность сервиса.
//
//Когда использовать Retry Pattern
//Временные сбои: Когда операции могут не удаваться из-за временных проблем, таких как сетевые сбои или перегрузка сервера.
//Улучшение надежности: Когда необходимо повысить надежность системы, обеспечивая успешное выполнение операций.
//Асинхронные операции: Когда операции могут быть выполнены асинхронно, и задержка в выполнении приемлема.
//Интеграция с внешними сервисами: Когда взаимодействие с внешними сервисами может быть ненадежным.

//Плюсы Retry Pattern
//Повышение надежности: Увеличивает вероятность успешного выполнения операций, которые могут временно не удаваться.
//Гибкость: Позволяет настроить количество попыток и интервалы между ними в зависимости от требований системы.
//Устойчивость к сбоям: Помогает системе справляться с временными сбоями без вмешательства пользователя.
//Простота реализации: Легко реализуется и интегрируется в существующие системы.

// Минусы Retry Pattern
// Задержки: Может увеличить время выполнения операций из-за повторных попыток.
// Перегрузка системы: Неправильная настройка может привести к перегрузке системы или внешнего сервиса из-за большого количества повторных попыток.
// Неэффективность при постоянных сбоях: Если сбой постоянный, повторные попытки не помогут, и могут даже ухудшить ситуацию.
// Сложность настройки: Требует тщательной настройки параметров повторных попыток, таких как количество попыток и интервалы.
package main

import (
	"errors"
	"fmt"
	"math/rand"
	"time"
)

// simulateOperation - симулирует операцию, которая может завершиться с ошибкой
func simulateOperation() error {
	if rand.Float32() < 0.7 { // 70% вероятность ошибки
		return errors.New("temporary error")
	}
	return nil
}

// retry - выполняет операцию с повторными попытками
func retry(attempts int, sleep time.Duration, operation func() error) error {
	for i := 0; i < attempts; i++ {
		err := operation()
		if err == nil {
			return nil
		}
		fmt.Printf("Attempt %d failed: %s\n", i+1, err)
		time.Sleep(sleep)
	}
	return errors.New("all attempts failed")
}

func main() {
	rand.Seed(time.Now().UnixNano())

	err := retry(5, 1*time.Second, simulateOperation)
	if err != nil {
		fmt.Println("Operation failed after retries:", err)
	} else {
		fmt.Println("Operation succeeded")
	}
}
