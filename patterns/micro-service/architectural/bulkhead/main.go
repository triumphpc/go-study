// Паттерн "Bulkhead" (переборка) используется для повышения устойчивости и надежности системы, разделяя её на
//изолированные компоненты или подсистемы. Это позволяет ограничить влияние сбоя в одной части системы на другие части,
//подобно тому, как переборки в корабле предотвращают затопление всего судна при повреждении одного отсека.
//
//Когда использовать Bulkhead Pattern
//Устойчивость к сбоям: Когда необходимо ограничить влияние сбоя в одной части системы на другие части.
//Изоляция компонентов: Когда требуется изолировать компоненты или подсистемы для предотвращения каскадных сбоев.
//Управление ресурсами: Когда необходимо управлять ресурсами, такими как потоки или соединения, для предотвращения их исчерпания.
//Высокая доступность: Когда требуется обеспечить высокую доступность системы, минимизируя влияние сбоев.

//Плюсы Bulkhead Pattern
//Повышенная устойчивость: Ограничивает влияние сбоев, предотвращая каскадные отказы.
//Изоляция: Обеспечивает изоляцию компонентов, что упрощает управление и отладку.
//Управление ресурсами: Позволяет эффективно управлять ресурсами, предотвращая их исчерпание.
//Гибкость: Легко адаптируется к изменяющимся условиям и требованиям.

//Минусы Bulkhead Pattern
//Сложность реализации: Требует тщательного проектирования и управления изоляцией компонентов.
//Распределение ресурсов: Необходимо правильно распределять ресурсы между компонентами, чтобы избежать их неэффективного использования.
//Потенциальные задержки: Может добавить задержки в обработку запросов из-за изоляции компонентов.
//Увеличение сложности системы: Может увеличить общую сложность системы из-за необходимости управления изолированными компонентами.

package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

// Task - структура, представляющая задачу
type Task struct {
	ID int
}

// worker - функция для обработки задач
func worker(id int, tasks <-chan Task, wg *sync.WaitGroup) {
	defer wg.Done()
	for task := range tasks {
		fmt.Printf("Worker %d processing task %d\n", id, task.ID)
		time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond) // Симулируем выполнение задачи
	}
}

func main() {
	rand.Seed(time.Now().UnixNano())

	const numWorkers = 3
	const numTasks = 10

	// Создаем каналы для изоляции задач
	taskChannels := make([]chan Task, numWorkers)
	for i := range taskChannels {
		taskChannels[i] = make(chan Task, numTasks/numWorkers)
	}

	var wg sync.WaitGroup

	// Запускаем рабочих для каждого канала
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go worker(i+1, taskChannels[i], &wg)
	}

	// Распределяем задачи по каналам
	for i := 1; i <= numTasks; i++ {
		taskChannels[i%numWorkers] <- Task{ID: i}
	}

	// Закрываем все каналы
	for _, ch := range taskChannels {
		close(ch)
	}

	// Ожидаем завершения всех задач
	wg.Wait()
}
