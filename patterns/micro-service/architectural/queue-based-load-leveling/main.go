// Паттерн "Queue-Based Load Leveling" используется для сглаживания нагрузки на систему, распределяя поступающие запросы
//или задачи через очередь. Это позволяет системе обрабатывать задачи с постоянной скоростью, даже если входящая нагрузка
//изменяется. Паттерн особенно полезен в распределенных системах, где необходимо управлять переменной нагрузкой и предотвращать
//перегрузку ресурсов.
//
//Когда использовать Queue-Based Load Leveling
//Переменная нагрузка: Когда система сталкивается с переменной нагрузкой, и необходимо сгладить пики нагрузки.
//Ограниченные ресурсы: Когда ресурсы ограничены, и необходимо предотвратить их перегрузку.
//Асинхронная обработка: Когда задачи могут быть обработаны асинхронно, без немедленного ответа.
//Улучшение надежности: Когда необходимо повысить надежность системы за счет управления нагрузкой и предотвращения отказов.

//Плюсы Queue-Based Load Leveling
//Сглаживание нагрузки: Позволяет системе обрабатывать задачи с постоянной скоростью, независимо от входящей нагрузки.
//Улучшение надежности: Предотвращает перегрузку системы и снижает риск отказов.
//Асинхронная обработка: Позволяет обрабатывать задачи асинхронно, что может улучшить производительность.
//Гибкость: Легко адаптируется к изменяющимся условиям нагрузки и требованиям.

// Минусы Queue-Based Load Leveling
// Задержки: Может добавить задержки в обработку задач, так как они помещаются в очередь.
// Сложность управления: Требует управления очередями и мониторинга их состояния.
// Потенциальные блокировки: Если очередь переполнена, это может привести к блокировке или потере задач.
// Дополнительные ресурсы: Может потребовать дополнительных ресурсов для управления очередями и обработки задач.
package main

import (
	"fmt"
	"time"
)

// Task - структура, представляющая задачу
type Task struct {
	ID int
}

// worker - функция для обработки задач
func worker(id int, tasks <-chan Task) {
	for task := range tasks {
		fmt.Printf("Worker %d processing task %d\n", id, task.ID)
		time.Sleep(time.Second) // Симулируем время обработки
	}
}

func main() {
	const numWorkers = 3
	tasks := make(chan Task, 10) // Создаем очередь задач с буфером

	// Запускаем несколько рабочих горутин
	for i := 1; i <= numWorkers; i++ {
		go worker(i, tasks)
	}

	// Добавляем задачи в очередь
	for i := 1; i <= 20; i++ {
		tasks <- Task{ID: i}
		fmt.Printf("Task %d added to queue\n", i)
		time.Sleep(500 * time.Millisecond) // Симулируем переменную нагрузку
	}

	close(tasks)                // Закрываем канал после добавления всех задач
	time.Sleep(5 * time.Second) // Ждем завершения всех задач
}
