// Паттерн "Runtime Reconfiguration" позволяет изменять конфигурацию приложения во время его выполнения без необходимости
//перезапуска. Это особенно полезно в системах, которые должны оставаться доступными и реагировать на изменения в реальном времени.
//Паттерн обеспечивает гибкость и адаптивность, позволяя приложениям динамически подстраиваться под изменяющиеся условия или требования.
//
//Когда использовать Runtime Reconfiguration Pattern
//Высокая доступность: Когда приложение должно оставаться доступным и не может быть перезапущено для применения изменений конфигурации.
//Динамическая адаптация: Когда необходимо адаптировать приложение к изменяющимся условиям, например, изменению нагрузки или доступности ресурсов.
//Управление конфигурацией: Когда требуется централизованное управление конфигурацией для нескольких приложений или сервисов.
//Частые изменения: Когда конфигурация приложения часто меняется, и перезапуск приложения для применения изменений непрактичен.

//Плюсы Runtime Reconfiguration Pattern
//Гибкость: Позволяет изменять конфигурацию приложения в реальном времени без перезапуска.
//Высокая доступность: Обеспечивает непрерывную работу приложения, минимизируя время простоя.
//Централизованное управление: Позволяет централизованно управлять конфигурацией для нескольких приложений.
//Адаптивность: Позволяет приложениям динамически адаптироваться к изменяющимся условиям.

//Минусы Runtime Reconfiguration Pattern
//Сложность реализации: Требует тщательной реализации и управления изменениями конфигурации.
//Потенциальные ошибки: Изменения конфигурации в реальном времени могут привести к ошибкам, если они не были тщательно протестированы.
//Безопасность: Необходимо обеспечить безопасность доступа к конфигурации, чтобы предотвратить несанкционированные изменения.
//Согласованность: Изменения конфигурации могут привести к временной несогласованности, если они не применяются одновременно ко всем компонентам.

package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"os/signal"
	"sync"
	"syscall"
	"time"
)

// Config - структура для хранения конфигурации
type Config struct {
	Setting1 string `json:"setting1"`
	Setting2 int    `json:"setting2"`
}

var (
	config     Config
	configLock sync.RWMutex
)

// loadConfig - загружает конфигурацию из файла
func loadConfig(filename string) error {
	data, err := ioutil.ReadFile(filename)
	if err != nil {
		return err
	}

	var newConfig Config
	if err := json.Unmarshal(data, &newConfig); err != nil {
		return err
	}

	configLock.Lock()
	config = newConfig
	configLock.Unlock()

	fmt.Println("Configuration reloaded:", config)
	return nil
}

// monitorConfig - следит за изменениями конфигурации
func monitorConfig(filename string) {
	for {
		time.Sleep(5 * time.Second) // Проверяем изменения каждые 5 секунд
		if err := loadConfig(filename); err != nil {
			fmt.Println("Error loading config:", err)
		}
	}
}

func main() {
	configFile := "config.json"

	// Загружаем начальную конфигурацию
	if err := loadConfig(configFile); err != nil {
		fmt.Println("Error loading initial config:", err)
		return
	}

	// Запускаем мониторинг конфигурации
	go monitorConfig(configFile)

	// Обрабатываем сигналы для корректного завершения работы
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
	<-sigChan

	fmt.Println("Shutting down...")
}
