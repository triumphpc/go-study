// Паттерн "Claim-Check" используется в интеграционных системах для управления передачей больших объемов данных между
//компонентами или сервисами. Вместо передачи больших данных напрямую через сообщения, паттерн предполагает сохранение
//данных в хранилище и передачу только ссылки (или "чека") на эти данные. Это позволяет уменьшить нагрузку на систему
//и улучшить производительность.
//
//Когда использовать Claim-Check Pattern
//Большие объемы данных: Когда необходимо передавать большие объемы данных между компонентами, и это может перегрузить систему.
//Оптимизация производительности: Когда требуется уменьшить объем данных, передаваемых через сообщения, чтобы улучшить производительность.
//Снижение нагрузки на сеть: Когда передача больших данных может перегрузить сеть или коммуникационные каналы.
//Управление ресурсами: Когда необходимо эффективно управлять ресурсами, такими как память и пропускная способность сети.

//Плюсы Claim-Check Pattern
//Улучшение производительности: Уменьшает объем данных, передаваемых через сообщения, что может улучшить производительность системы.
//Снижение нагрузки на сеть: Уменьшает нагрузку на сеть и коммуникационные каналы, передавая только ссылки на данные.
//Гибкость: Позволяет легко управлять большими объемами данных, сохраняя их в хранилище.
//Безопасность: Может улучшить безопасность, ограничивая доступ к данным через ссылки и контролируя доступ к хранилищу.

//Минусы Claim-Check Pattern
//Сложность управления: Требует управления хранилищем данных и ссылками на данные.
//Зависимость от хранилища: Зависит от доступности и надежности хранилища данных.
//Потенциальные задержки: Может добавить задержки из-за необходимости извлечения данных из хранилища.
//Безопасность ссылок: Необходимо обеспечить безопасность ссылок, чтобы предотвратить несанкционированный доступ к данным.

package main

import (
	"fmt"
	"sync"
)

// Storage - структура, представляющая хранилище данных
type Storage struct {
	data map[string]string
	mu   sync.RWMutex
}

// NewStorage - создает новое хранилище
func NewStorage() *Storage {
	return &Storage{data: make(map[string]string)}
}

// Save - сохраняет данные в хранилище и возвращает ключ
func (s *Storage) Save(data string) string {
	s.mu.Lock()
	defer s.mu.Unlock()
	key := fmt.Sprintf("key%d", len(s.data)+1)
	s.data[key] = data
	return key
}

// Retrieve - извлекает данные из хранилища по ключу
func (s *Storage) Retrieve(key string) (string, bool) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	data, exists := s.data[key]
	return data, exists
}

func main() {
	storage := NewStorage()

	// Сохраняем данные и получаем ключ
	key := storage.Save("Large data payload")

	// Передаем только ключ (чек) через сообщение
	fmt.Println("Claim check (key):", key)

	// Извлекаем данные из хранилища по ключу
	if data, exists := storage.Retrieve(key); exists {
		fmt.Println("Retrieved data:", data)
	} else {
		fmt.Println("Data not found for key:", key)
	}
}
