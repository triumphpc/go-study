// Паттерн "Orchestration" используется для координации и управления взаимодействием между различными компонентами или
//сервисами в системе. В отличие от паттерна "Choreography", где каждый сервис самостоятельно управляет своим взаимодействием с
//другими, в оркестрации один центральный компонент (оркестратор) управляет всеми взаимодействиями. Это позволяет централизовать
//логику управления и упрощает координацию сложных процессов.
//
//Когда использовать Orchestration Pattern
//Централизованное управление: Когда необходимо централизовать управление взаимодействиями между сервисами.
//Сложные процессы: Когда требуется координировать сложные процессы, состоящие из множества шагов и взаимодействий.
//Упрощение логики: Когда необходимо упростить логику взаимодействия, переместив её в один центральный компонент.
//Контроль и мониторинг: Когда требуется централизованный контроль и мониторинг выполнения процессов.

//Плюсы Orchestration Pattern
//Централизованное управление: Обеспечивает централизованное управление и координацию всех взаимодействий.
//Упрощение логики: Перемещает логику взаимодействия в один компонент, упрощая управление и отладку.
//Контроль и мониторинг: Позволяет легко контролировать и мониторить выполнение процессов.
//Гибкость: Легко адаптируется к изменениям в процессе или взаимодействиях.

//Минусы Orchestration Pattern
//Единая точка отказа: Оркестратор может стать единой точкой отказа, если не предусмотрены механизмы отказоустойчивости.
//Сложность реализации: Требует тщательной реализации и управления логикой взаимодействия.
//Зависимость от оркестратора: Все взаимодействия зависят от центрального компонента, что может ограничить гибкость системы.
//Потенциальные задержки: Может добавить задержки в обработку запросов из-за централизованного управления.

package main

import (
	"fmt"
	"time"
)

// Event - структура, представляющая событие
type Event struct {
	Name string
	Data string
}

// Orchestrator - оркестратор, управляющий взаимодействием между сервисами
type Orchestrator struct{}

// ProcessOrder - метод оркестратора для обработки заказа
func (o *Orchestrator) ProcessOrder(orderID string) {
	fmt.Println("Orchestrator: Starting order processing for", orderID)
	o.checkInventory(orderID)
	o.prepareShipment(orderID)
	fmt.Println("Orchestrator: Order processing completed for", orderID)
}

// checkInventory - проверяет наличие товара на складе
func (o *Orchestrator) checkInventory(orderID string) {
	fmt.Println("Orchestrator: Checking inventory for", orderID)
	time.Sleep(500 * time.Millisecond) // Симулируем задержку
}

// prepareShipment - подготавливает отправку товара
func (o *Orchestrator) prepareShipment(orderID string) {
	fmt.Println("Orchestrator: Preparing shipment for", orderID)
	time.Sleep(500 * time.Millisecond) // Симулируем задержку
}

func main() {
	orch := &Orchestrator{}
	orch.ProcessOrder("Order123")
}
