// Паттерн "Priority Queue" используется для управления элементами в очереди на основе их приоритета. В отличие от
//обычной очереди, где элементы обрабатываются в порядке их добавления (FIFO — First In, First Out), в приоритетной
//очереди элементы с более высоким приоритетом обрабатываются раньше, независимо от их положения в очереди.
//
//Когда использовать Priority Queue Pattern
//Управление задачами: Когда необходимо обрабатывать задачи в зависимости от их важности или срочности.
//Распределение ресурсов: Когда ресурсы ограничены, и необходимо обслуживать более важные запросы в первую очередь.
//Системы реального времени: Когда требуется гарантировать, что критически важные задачи будут выполнены вовремя.
//Планирование: Когда необходимо планировать выполнение задач на основе их приоритета.

//Плюсы Priority Queue Pattern
//Эффективное управление задачами: Позволяет обрабатывать более важные задачи раньше, улучшая общее управление задачами.
//Гибкость: Легко адаптируется к изменяющимся требованиям приоритизации.
//Оптимизация ресурсов: Обеспечивает более эффективное использование ресурсов, обслуживая более важные задачи в первую очередь.
//Поддержка различных стратегий: Позволяет реализовать различные стратегии приоритизации в зависимости от потребностей системы.

//Минусы Priority Queue Pattern
//Сложность реализации: Реализация приоритетной очереди может быть сложнее, чем обычной очереди.
//Задержки для низкоприоритетных задач: Задачи с низким приоритетом могут испытывать значительные задержки в обработке.
//Управление приоритетами: Требуется тщательное управление и настройка приоритетов, чтобы избежать проблем с производительностью.
//Потенциальные блокировки: В некоторых случаях задачи с низким приоритетом могут никогда не быть обработаны, если высокоприоритетные задачи постоянно добавляются.

// Пакет container/heap в Go предоставляет интерфейс и функции для работы с кучей (heap), которая является
// специализированной структурой данных, используемой для реализации приоритетных очередей. Куча — это бинарное дерево,
// которое удовлетворяет свойству кучи: каждый узел имеет значение, которое не меньше (или не больше, в зависимости от
// типа кучи) значений его дочерних узлов. Это позволяет эффективно извлекать минимальный (или максимальный) элемент.
package main

import (
	"container/heap"
	"fmt"
)

// Item - элемент очереди с приоритетом
type Item struct {
	value    string // Значение элемента
	priority int    // Приоритет элемента
	index    int    // Индекс элемента в куче
}

// PriorityQueue - приоритетная очередь, реализующая интерфейс heap.Interface
type PriorityQueue []*Item

func (pq PriorityQueue) Len() int { return len(pq) }

func (pq PriorityQueue) Less(i, j int) bool {
	// Чем выше приоритет, тем раньше элемент будет обработан
	return pq[i].priority > pq[j].priority
}

func (pq PriorityQueue) Swap(i, j int) {
	pq[i], pq[j] = pq[j], pq[i]
	pq[i].index = i
	pq[j].index = j
}

func (pq *PriorityQueue) Push(x interface{}) {
	n := len(*pq)
	item := x.(*Item)
	item.index = n
	*pq = append(*pq, item)
}

func (pq *PriorityQueue) Pop() interface{} {
	old := *pq
	n := len(old)
	item := old[n-1]
	item.index = -1 // Для безопасности
	*pq = old[0 : n-1]
	return item
}

// update изменяет приоритет элемента в очереди
func (pq *PriorityQueue) update(item *Item, value string, priority int) {
	item.value = value
	item.priority = priority
	heap.Fix(pq, item.index)
}

func main() {
	// Создаем приоритетную очередь и добавляем элементы
	pq := make(PriorityQueue, 0)
	heap.Init(&pq)

	heap.Push(&pq, &Item{value: "task1", priority: 3})
	heap.Push(&pq, &Item{value: "task2", priority: 1})
	heap.Push(&pq, &Item{value: "task3", priority: 2})
	heap.Push(&pq, &Item{value: "task4", priority: 3})
	heap.Push(&pq, &Item{value: "task5", priority: 6})

	// Извлекаем элементы из очереди в порядке приоритета
	for pq.Len() > 0 {
		item := heap.Pop(&pq).(*Item)
		fmt.Printf("Processing %s with priority %d\n", item.value, item.priority)
	}
}
