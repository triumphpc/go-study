// NFKC — это одна из форм нормализации строк в стандарте Unicode. Давайте разберёмся подробнее, что это означает и зачем применяется.Что такое нормализация Unicode?Unicode предоставляет уникальный код для каждого символа, но один и тот же визуальный символ может иметь несколько разных представлений в кодировке Unicode. Например, буква "é" может быть представлена как один символ (U+00E9) или как комбинация двух символов: буква "e" (U+0065) и акут (U+0301). Это создаёт сложности при сравнении строк, поиске и обработке текста.Чтобы решить эту проблему, Unicode определяет формы нормализации, которые преобразуют строки в стандартный формат. Существует четыре основные формы нормализации:
//NFC (Normalization Form C) — Каноническая композиция.
//NFD (Normalization Form D) — Каноническая декомпозиция.
//NFKC (Normalization Form KC) — Компатибельная композиция.
//NFKD (Normalization Form KD) — Компатибельная декомпозиция.
//Что такое NFKC?NFKC расшифровывается как Normalization Form Compatibility Composition. Это комбинированная форма нормализации, которая включает в себя как компатибельную декомпозицию (NFKD), так и каноническую композицию (NFC).Компатибельная нормализация (отсюда "K" в NFKC) не только разлагает символы на их базовые формы, но и заменяет некоторые символы на их "компатибельные" эквиваленты. Это означает, что некоторые символы, которые выглядят по-разному, но имеют похожее или эквивалентное значение, будут приведены к одному стандартному виду.Зачем использовать NFKC?Использование NFKC полезно в следующих случаях:
//Сравнение строк: Чтобы избежать различий между эквивалентными символами, которые могут иметь разные представления в Unicode.
//Поиск и индексация: Для более точного поиска без учёта вариаций представления символов.
//Обработка пользовательского ввода: Для стандартизации данных, введённых пользователями, особенно в многоязычных приложениях.
//ПримерРассмотрим пример с символом "ﬃ" (ligature):
//Без нормализации: "ﬃ" (U+FB03)
//После применения NFKC: "ffi" (U+0066 U+0066 U+0069)
//Таким образом, NFKC преобразует совместимые лигатуры и другие подобные символы в их базовые формы, что облегчает обработку и сравнение строк.ИтогИспользование norm.NFKC.String(s) в вашем коде гарантирует, что строка s будет преобразована в стандартный форму NFKC, что упрощает её дальнейшую обработку, сравнение и поиск, устраняя различия в представлении эквивалентных символов.

package main

import (
	"fmt"

	"golang.org/x/text/unicode/norm"
)

func normString(s string) string {
	return norm.NFKC.String(s)
}

func main() {
	// Пример 1: Составные символы
	s1 := "é"       // один символ (U+00E9)
	s2 := "e\u0301" // буква e + диакритический знак (U+0065 + U+0301)

	fmt.Printf("Без нормализации: %v\n", s1 == s2)                        // false
	fmt.Printf("С нормализацией: %v\n", normString(s1) == normString(s2)) // true

	// Пример 2: Лигатуры
	s3 := "ﬃ"   // лигатура ffi (U+FB03)
	s4 := "ffi" // три отдельные буквы

	fmt.Printf("\nБез нормализации: %v\n", s3 == s4)                      // false
	fmt.Printf("С нормализацией: %v\n", normString(s3) == normString(s4)) // true

	// Пример 3: Специальные символы
	s5 := "①" // закрашенная цифра один (U+2460)
	s6 := "1" // обычная цифра один

	fmt.Printf("\nБез нормализации: %v\n", s5 == s6)                      // false
	fmt.Printf("С нормализацией: %v\n", normString(s5) == normString(s6)) // true

	// Вывод оригинальных и нормализованных строк
	fmt.Printf("\nОригинальные строки: %s %s\n", s1, s2)
	fmt.Printf("Нормализованные строки: %s %s\n", normString(s1), normString(s2))

	fmt.Printf("\nОригинальные строки: %s %s\n", s3, s4)
	fmt.Printf("Нормализованные строки: %s %s\n", normString(s3), normString(s4))

	fmt.Printf("\nОригинальные строки: %s %s\n", s5, s6)
	fmt.Printf("Нормализованные строки: %s %s\n", normString(s5), normString(s6))
}
