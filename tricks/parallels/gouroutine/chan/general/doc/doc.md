1. Представляет из себя структуру с набором параметров
   ![Screenshot20231113at201103.png](assets/Screenshot 2023-11-13 at 20.11.03.png)

   - qcount - количество элементов в буфере
   - dataqsize - размерность буфера
   - buf - указатель на сам буфер
   - closed - флаг, закрыт ли канал. Используется тип 32 бита, потому что при работе с этим параметров используются атомики. Т.е. состояние изменяется не блокируя сам канал.
   - recvq и sendq - связанный список горутин, который ожидают чтение или запись из канала
   - recvx и sendx - номера ячеек буфера из которых происходит чтение/запись
   - lock - это Mutex
2. Буффер, это циклическая очередь

![Screenshot20231113at204818.png](assets/Screenshot 2023-11-13 at 20.48.18.png)

3. При записи в буферизированный канал указатель sendx смещает позицию

![Screenshot20231113at205001.png](assets/Screenshot 2023-11-13 at 20.50.01.png)

4. При чтении смещается соответсвующий индекс,

   ![image.png](assets/image.png)

5. При отправке в буферизированный канал созздается лок и создается копия данных, помещается в ячейку
![img.png](img.png)

6. После этого разблокируется mutex. После чего с ним может работать другая горутина. 

7. При чтении прозойдет все тоже самое:  
- блокировка мьютекса
- копирование данных ресиверу 
- разблокировка мьютекса
![img_1.png](img_1.png)

8. При наполнении канал ставит горутину на паузу: 
![img_2.png](img_2.png)
9. Посмотрим как это происходит: 
- параллельно работают не горутины и потоки OS
![img_3.png](img_3.png)
- Все горутины выстраиваются в очереди в рамках потоков
![img_4.png](img_4.png)
- последовательно выполняются горутины и между ними переключается контекст
10. При записи в канал: 
- канал вызывает функцю gopark()
- которая обращается к шедулеру, который менет статус горутины с running на waiting
![img_5.png](img_5.png)
- после этого разрыавается связь горутины с тредом
![img_6.png](img_6.png)
- если в runqueue есть ожидающая горутина, то планировщик переключает контекст треда на другую горутину

11. Когда проиходит парковка горутины, помимо этого происходит следующие дейстивя: 
- горутина попадает в очередь sendq
- это очередь есть у каждого канала 
- он представляет из себя ссылку на структуру waitq, которая хранит у себя указатели на начало и конец связанного списка
- список представлет из себя структуру sudog
- параметр G представлет из себя ту самую спящую горутину
- elem - это тот элемент, который мы отправляем
![img_8.png](img_8.png)
- итак горутина и данные у нас помещены в sudog и лежат ам пока не придет ридер
![img_9.png](img_9.png)

12. Первым делом ридер забирает элемент из очереди 
![img_10.png](img_10.png)
- видно что в буфере появилась свободная ячейка и наша спящая горутина может проснуться
- ресивер идет и проверяет, а есть ли в очереди sendq свящие горутины?
![img_11.png](img_11.png)
- ресивер возьмет элемент из подвисшей очереди и положит его в буфер 
![img_12.png](img_12.png)
- и третьим шагом ресивер возьмется за пробуждение горутны
- ресивер вызывает goready  и меняется состояние спящей горутины на runnable
![img_13.png](img_13.png)
- получается, что лок происхоит один раз и канал начинает быть доступен на запись как кто-то читает из него элемент

13. В случае, если sender отправляет элемент и в этот момент есть горутина с Reader, которая ждет на парковке, то происходит оптимизация - Sender сразу отправляет sudoG структуру Readerа этот элемента
![img_14.png](img_14.png)

14. В небуферизированных каналах такая оптимизация используется напрямую
![img_15.png](img_15.png)

15. Итог
![img_16.png](img_16.png)

16. При дебаге видно что из себя представляет структура chan
![img_17.png](img_17.png)