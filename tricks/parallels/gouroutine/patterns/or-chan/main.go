package main

import (
	"fmt"
	"time"
)

// Иногда вы можете захотеть объединить один или несколько завершенных каналов в один выполненный канал, который закрывается,
//если закрывается какой-либо из составляющих его каналов. Вполне приемлемо, хотя и многословно, написать оператор select,
//который выполняет это связывание; однако иногда вы не можете знать количество готовых каналов, с которыми работаете во время выполнения.
//В этом случае или если вы просто предпочитаете однострочник, вы можете объединить эти каналы вместе, используя шаблон or-channel.
//Этот шаблон создает составной канал выполнения с помощью рекурсии и горутин.

func or1(channels ...<-chan struct{}) <-chan struct{} {
	done := make(chan struct{})

	go func() {
		defer close(done)
		for {
			for _, ch := range channels {
				select {
				case <-ch: // Если какой либо составной канал закрывается - done тоже закрывается
					return
				default:
				}
			}
		}
	}()

	return done
}

// 1. Здесь у нас есть наша функция or, которая принимает вариативные срезы каналов и возвращает единственный канал.
// 2. Поскольку это рекурсивная функция, мы должны установить критерии завершения. Во-первых, если вариативный срез пуст, мы просто возвращаем нулевой канал. Это согласуется с идеей отсутствия каналов; мы не ожидаем, что составной канал что-нибудь сделает.
// 3. Наш второй критерий завершения гласит, что если наш вариативный срез содержит только один элемент, мы просто возвращаем этот элемент.
// 4. Вот основная часть функции и место, где происходит рекурсия. Мы создаем горутину, чтобы мы могли ждать сообщений на наших каналах без блокировки.
// 5.  Из-за того, как мы рекурсивны, каждый рекурсивный вызов или, по крайней мере, будет иметь два канала. В качестве оптимизации, позволяющей ограничить количество горутин, мы помещаем здесь специальный случай для вызовов только двух каналов или только с ними.
// 6. Здесь мы рекурсивно создаем or-канал из всех каналов в нашем срезе после третьего индекса, а затем выбираем из него. Это рекуррентное отношение разрушит превратите остальную часть среза в or-каналы, чтобы сформировать дерево, из которого вернется первый сигнал. Мы также передаем канал orDone, чтобы при выходе из дерева горутины выходили из дерева.
func or(channels ...<-chan struct{}) <-chan struct{} { // 1
	switch len(channels) {
	case 0: // 2
		return nil
	case 1: // 3
		return channels[0] // <-or(ch) == <-ch
	}

	orDone := make(chan struct{})
	go func() { // 4
		defer close(orDone)

		switch len(channels) {
		case 2: // 5
			select {
			case <-channels[0]:
			case <-channels[1]:
			}
		default: // 6
			select {
			case <-channels[0]:
			case <-channels[1]:
			case <-channels[2]:
			case <-or(append(channels[3:], orDone)...): // 6
			}
		}
	}()
	return orDone
}

// 1. Эта функция просто создает канал, который закроется по истечении времени, указанного в after.
// 2. Здесь мы примерно отслеживаем, когда канал из функции или начинает блокироваться.
// 3. И здесь мы печатаем время, которое потребовалось для чтения.
func main() {
	sig := func(after time.Duration) <-chan struct{} {
		c := make(chan struct{}) // 1
		go func() {
			defer close(c)
			time.Sleep(after)
		}()
		return c
	}
	start := time.Now() // 2
	<-or(
		sig(2*time.Hour),
		sig(5*time.Minute),
		sig(1*time.Second),
		sig(1*time.Hour),
		sig(1*time.Minute),
	)
	fmt.Printf("done after %v", time.Since(start)) // 3

}
