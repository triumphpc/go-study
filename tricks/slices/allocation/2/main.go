package main

// Выделение памяти в слайсе

// Статический анализатор для анализа предварительной аллокации для массива
// https://github.com/alexkohler/prealloc

import (
	"fmt"
	"reflect"
)

func main() {

	a := []string{"Шито"}
	fmt.Println(len(a), cap(a))                             // 1 1
	fmt.Printf("%#v %p\n", reflect.ValueOf(a).Pointer(), a) // 0xc00010c220

	a = append(a, "Крыто")
	fmt.Println(len(a), cap(a))                       // 2 2
	fmt.Printf("%#v\n", reflect.ValueOf(a).Pointer()) // 0xc000130000

	a = append(a, "Корыто")
	fmt.Println(len(a), cap(a))                       // 3 4 (внезапно)
	fmt.Printf("%#v\n", reflect.ValueOf(a).Pointer()) // 0xc00012e040

	// на самом деле ссылки будут разными при каждом запуске,
	// но тут главное можно увидеть, что после каждого добавления элемента
	// и, как следствие, увеличения емкости массива,
	// срез начинает ссылаться на новую область памяти

	// также в последнем примере мы добавили один элемент,
	// а ёмкость увеличился на два, это связано с оптимизацией -
	// постоянно перемещать элементы в новую область памяти дорого,
	// поэтому Go пытается нам помочь и заранее увеличить размер массива

	// если мы теперь добавим четвертый элемент, ссылка уже не поменяется,
	// потому что емкость останется прежней

	a = append(a, "_")
	fmt.Println(len(a), cap(a))                       // 4 4
	fmt.Printf("%#v\n", reflect.ValueOf(a).Pointer()) // 0xc00012e040

	b := make([]int, 2, 3)
	// тут мы создаём срез длинной два и ёмкостью три
	// так как мы задаем длину, в срезе уже будут элементы
	// со значениями по умолчанию, это просто для примера,
	// вторым аргументом можно было просто передать 0

	fmt.Printf("%#v\n", b)      // []int{0, 0}
	fmt.Println(len(b), cap(b)) // 2 3

	// на этот раз создадим срез, а не массив,
	// на основе которого дальше создадим новый срез,
	// так как в жизни, чаще в основе наших срезов
	// будут лежать другие срезы, но в этом примере с массивом
	// всё работало бы аналогично
	c := []int{1, 2, 3, 4, 5, 6}

	// создаём новый срез, от нашего базового среза
	s := c[:2]
	fmt.Printf("%#v\n", s)      // []int{1, 2}
	fmt.Println(len(s), cap(s)) // 2 6

	s1 := c[2:3]
	fmt.Printf("%#v\n", s1) // []int{3}
	// Тут новый срез, создается новый базовый массив: [3 4 5 6]
	// Слайс ссылается на новый базовый массив [3 x x x]
	fmt.Println(len(s1), cap(s1)) // 1 4
	// тут нужно обратить внимание, что cap равняется шести,
	// всё потому что новый срез создаётся с таким объёмом,
	// чтобы уместиться в объём базового,
	// при этом быть максимально большим
	// например, у среза a[2:3] объём был бы равен четырём,
	// так как мы "отрезали" кусок от исходного среза,
	// начиная со второго элемента (цифры 3), и до конца изначально
	// выделенной памяти осталось ещё четыре ячейки памяти

	// дальше делаем несколько добавлений в конец нашего нового среза
	s = append(s, 800)
	s = append(s, 900)

	// и смотрим что же получилось
	fmt.Printf("%#v\n", s) // []int{1, 2, 800, 900}
	// выглядит всё хорошо: два элемента добавились в срез
	fmt.Println(len(s), cap(s)) // 4 6
	// тут тоже всё понятно: к отрезанным двум элементам
	// добавили ещё два элемента и длина стала четыре

	// но посмотрим что стало с исходным нашим срезом
	fmt.Printf("%#v\n", a) // []int{1, 2, 800, 900, 5, 6}
	// append не просто добавил элементы к новому срезу,
	// он их записал поверх элементов исходного среза
	// и меняет по указателю значения базового массива
}
