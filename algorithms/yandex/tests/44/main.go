package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"strconv"
)

// Частичная сортировка
// После того, как Гоша узнал про сортировку слиянием и быструю сортировку, он решил придумать свой метод сортировки, который предполагал бы разделение данных на части.
//
//Назвал он свою сортировку Частичной.
//
//Этим методом можно отсортировать n уникальных чисел a1, a2, … , an, находящихся в диапазоне от 0 до n - 1.
//
//Алгоритм сортировки состоит из трёх шагов:
//* Разбить исходную последовательность на k блоков B1, …, Bk. Блоки могут иметь разные размеры. Если размер блока i равен si, то B1 ={ a1, …, as1 }, B2 = { as1 + 1, … , as1 + s2 } и так далее.
//* Отсортировать каждый из блоков.
//* Объединить блоки — записать сначала отсортированный блок B1, потом B2, … , Bk
//Частичная сортировка лучше обычной в том случае, если в первом пункте у нас получится разбить последовательность на большое число блоков. Однако далеко не каждое такое разбиение подходит. Определите максимальное число блоков, на которое можно разбить исходную последовательность, чтобы сортировка отработала корректно.
//
//Рассмотрим пример: a = [3, 2, 0, 1, 4, 6, 5].
//
//Минимальный размер первого блока B1 равен 4. Если взять лишь первые два элемента, то отсортированная последовательность будет начинаться с двойки, что неправильно. Если взять первые три элемента, то последовательность будет начинаться с нуля, но после него сразу же пойдёт двойка. Первые четыре элемента уже гарантируют корректный префикс после объединения блоков. Четвёрку можно взять как самостоятельный блок из одного элемента. Последние два элемента надо объединить в третий блок. Таким образом:
//
//B1 = { 3, 2, 0, 1 }
//
//B2 = { 4 }
//
//B3 = { 6, 5 }
//
//В данном примере ответ равен 3. Максимальное число блоков равно трём.

// тут определенрие по наполнению последовательности

func main() {
	task(os.Stdin, os.Stdout)
}

func task(src io.Reader, dst io.Writer) {
	scanner := bufio.NewScanner(src)
	scanner.Split(bufio.ScanWords)
	scanner.Scan()
	n, _ := strconv.Atoi(scanner.Text())
	numbers := make([]int, 0)
	for i := 0; i < n; i++ {
		scanner.Scan()
		intVal, _ := strconv.Atoi(scanner.Text())
		numbers = append(numbers, intVal)
	}

	result := 0
	min := 0
	max := 0
	sequenceComplete := false
	minFound := false
	foundValues := make([]int, n, n)

	for i := 0; i < n; i++ {
		foundValues[numbers[i]] = 1
		if numbers[i] > max {
			max = numbers[i]
		}
		sequenceComplete = false
		if numbers[i] == min {
			minFound = true
		}
		// проверка последовательности
		sequenceComplete = true
		if minFound {
			for j := min; j <= max; j++ {
				// отсутствует один из элементов
				if foundValues[j] == 0 {
					sequenceComplete = false
					break
				}
			}
			if sequenceComplete {
				min = max + 1
				result++
			}
		}
	}
	if !sequenceComplete {
		result++
	}
	fmt.Fprintf(dst, "%d\n", result)
}
