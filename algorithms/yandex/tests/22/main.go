package main

import (
	"bufio"
	"io"
	"math"
	"os"
	"strconv"
)

// Фибоначчи по модулю
// У Тимофея было очень много стажёров, целых N (0 ≤ N ≤ 106) человек. Каждый стажёр хотел быть лучше своих
//предшественников, поэтому i-й стажёр делал столько коммитов, сколько делали два предыдущих стажёра в сумме.
//Два первых стажёра были менее инициативными — они сделали по одному коммиту.
//Пусть Fi —– число коммитов, сделанных i-м стажёром (стажёры нумеруются с нуля). Первые два стажёра сделали
//по одному коммиту: F0=F1=1. Для всех i≥ 2 выполнено Fi=Fi−1+Fi−2.
//Определите, сколько кода напишет следующий стажёр –— найдите последние k цифр числа Fn.
//
//
//Как найти k последних цифр
//Чтобы вычислить k последних цифр некоторого числа x, достаточно взять остаток от его деления на число 10k.
//Эта операция обозначается как x mod 10k. Узнайте, как записывается операция взятия остатка по модулю в вашем языке программирования.
//Также обратите внимание на возможное переполнение целочисленных типов, если в вашем языке такое случается.

// Т.е. выводим последние k цифр числа из i последовательности фибоначи
// 10 2 (1 1 2 3 5 8 13 21 34 55 89)
// 89

// Модуль x mod 10^k - означает что вычислить k последних цифр некоторого числа x, достаточно взять остаток от его деления на число 10k
// mod10(2) = 100 = 10*10

func fi(n int, k int) int {
	if n <= 1 {
		return 1
	}
	result := 0
	fn1, fn2 := 1, 1

	for i := 2; i <= n; i++ {
		result = (fn1 + fn2) % int(math.Pow10(k)) // дотаточно последние остаток, чтоб в конце его же получить
		fn2 = fn1                                 // тут получается меняем местами
		fn1 = result

	}

	return result
}

func task(src io.Reader, dst io.Writer) {
	writer := bufio.NewWriter(dst)
	defer func() {
		writer.Flush()
	}()

	scanner := bufio.NewScanner(src)
	scanner.Split(bufio.ScanWords)
	scanner.Scan()
	num, _ := strconv.Atoi(scanner.Text())
	scanner.Scan()
	k, _ := strconv.Atoi(scanner.Text())
	writer.WriteString(strconv.Itoa(fi(num, k)) + "\n")
}

func main() {

	task(os.Stdin, os.Stdout)
}
