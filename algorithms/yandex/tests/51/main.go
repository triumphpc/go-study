package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

//Поисковая система.
// В этой задаче можно пользоваться хеш-таблицами из стандартных библиотек.
//Тимофей пишет свою поисковую систему.
//Имеется n документов, каждый из которых представляет собой текст из слов. По этим документам требуется построить поисковый индекс. На вход системе будут подаваться запросы. Запрос —– некоторый набор слов. По запросу надо вывести 5 самых релевантных документов.
//Релевантность документа оценивается следующим образом: для каждого уникального слова из запроса берётся число его вхождений в документ, полученные числа для всех слов из запроса суммируются. Итоговая сумма и является релевантностью документа. Чем больше сумма, тем больше документ подходит под запрос.
//Сортировка документов на выдаче производится по убыванию релевантности. Если релевантности документов совпадают —– то по возрастанию их порядковых номеров в базе (то есть во входных данных).
//Подумайте над случаями, когда запросы состоят из слов, встречающихся в малом количестве документов. Что если одно слово много раз встречается в одном документе?
//Формат ввода
//
//В первой строке дано натуральное число n —– количество документов в базе (1 ≤ n ≤ 104).
//Далее в n строках даны документы по одному в строке. Каждый документ состоит из нескольких слов, слова отделяются друг от друга одним пробелом и состоят из маленьких латинских букв. Длина одного текста не превосходит 1000 символов. Текст не бывает пустым.
//В следующей строке дано число запросов —– натуральное число m (1 ≤ m ≤ 104). В следующих m строках даны запросы по одному в строке. Каждый запрос состоит из одного или нескольких слов. Запрос не бывает пустым. Слова отделяются друг от друга одним пробелом и состоят из маленьких латинских букв. Число символов в запросе не превосходит 100.
//Формат вывода
//
//Для каждого запроса выведите на одной строке номера пяти самых релевантных документов. Если нашлось менее пяти документов, то выведите столько, сколько нашлось. Документы с релевантностью 0 выдавать не нужно.

func main() {
	task(os.Stdin, os.Stdout)
}

func task(src io.Reader, dst io.Writer) {
	scanner := bufio.NewScanner(src)
	//scanner.Split(bufio.ScanWords)
	scanner.Scan()
	n, _ := strconv.Atoi(scanner.Text())

	// 1. Подсчитаем вхождения в наименовании документов и их веса
	docsWeights := make([]map[string]uint, n)

	for i := 0; i < n; i++ {
		scanner.Scan()
		words := strings.Split(scanner.Text(), " ")
		docsWeights[i] = make(map[string]uint, len(words))

		for _, w := range words {
			docsWeights[i][w]++
		}
	}

	scanner.Scan()
	n, _ = strconv.Atoi(scanner.Text())
	phrasesWeightInDocs := make(map[int]uint, len(docsWeights))

	for i := 0; i < n; i++ {
		scanner.Scan()
		words := strings.Split(scanner.Text(), " ")

		// 2. Подсчитываем вес для всех
		for _, w := range words {
			for dID, dws := range docsWeights {
				phrasesWeightInDocs[dID] += dws[w]
			}
		}

		fmt.Println(phrasesWeightInDocs)

		keys := make([]int, 0, len(phrasesWeightInDocs))
		for id := range phrasesWeightInDocs {
			keys = append(keys, id)
		}

		// 3. Сразу выведем релевантные
		sort.SliceStable(keys, func(i, j int) bool {
			return phrasesWeightInDocs[keys[i]] > phrasesWeightInDocs[keys[j]]
		})

		fmt.Fprint(os.Stdout, keys, "\n")
	}
}
